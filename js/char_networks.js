let char_data = cleaned_path+"selected_chars.csv"
let association_network = cleaned_path+ "association_network.json"

const defaultEdgeColor = "rgba(200,200,200,0.2)"
const notSelectedEdgeColor = "rgba(220,220,220,0.2)"
const selectedEdgeColor = "rgba(140,140,140,1)"
const neighbourNodeColor = "rgba(140,140,140,1)"
const selectedNodeColor = "rgba(255, 0, 0, 1)"
const notSelectedNodeColor = "rgba(220,220,220,0.2)"
const communityColors = /*["#1AC3A6", "#34CF7A",*/ ["#41A1E1", "#A667BF", "#F2C500","#EA8B1D", "#EB5D49", "#475B6F", "#ECF0F1", "#9FAEAF"]

/**
 * Clear the association list displayed on tthe webpage
 */
function clearCommonAssoc(){
  var ul = document.getElementById("common-association-list")
  ul.innerHTML = ""
}

/**
 *  Create the list of common association between people.
 * @param the list of association that the select characters have in common.
 */
function createAllList(assoc_in_common){
  clearCommonAssoc()
  var ul = document.getElementById("common-association-list")
  assoc_in_common.forEach(e=>{
    var li = document.createElement("li")
    li.appendChild(document.createTextNode(e))
    li.className = "list-group-item list-group-item-dark";
    ul.appendChild(li);
  })
}

class SigmaGraph{
  constructor(container){
    // saved variables
    self.container = container
    self.edges = []
    self.nodes = []
    self.selected_nodes = new Set()
    self.selected_neighbors = new Set()
    self.s = null

    // src: https://github.com/jacomyal/sigma.js/issues/715 function to get the neighbours in the graph
    sigma.classes.graph.addMethod('neighbors', function(nodeId) {
      var k,
        neighbors = [],
        index = this.allNeighborsIndex[nodeId] || {};
    
      for (k in index)
        neighbors.push(this.nodesIndex[k].id)
    
      return neighbors;
      });
  }

  
  /**
   * Create all the nodes in the graph
   * @param nodes the node list
   */
  create_nodes(nodes){
    nodes.forEach(node => {
      self.nodes.push({
        id:node.id,
        label:node.name,
        x:node.x, // x position generated by NetworkX
        y:node.y, // y position generated by networkx
        color:communityColors[node.community], // default color 
        size:4,
        node_data:node // all the data of the nodes
    })
  })
}

  /**
   * Create all the edges in the graph
   * @param edges the edge list
   */
  create_edges(edges){
    edges.forEach(edge=>{
      self.edges.push({
        id:edge.id,
        source: edge.source,
        target:edge.target,
        color:defaultEdgeColor
      })
    })
  }

  /**
   * Filter out edges that are not in the selected associations
   */
  filter_nodes_and_edges(){
    // set with the selected associations
    var set2 = new Set(self.active_association)
    var toKeep = [...self.nodes].filter(node => {
      // create a set with the association of the curernt node
      var set = new Set(node.node_data.associated_groups)
      // Intersection of the association of the current node with the requested associations
      const intersection = new Set([...set].filter(element => set2.has(element)))
      return intersection.size > 0
    }).map(node=>node.id) // map the list to the node id

    self.s.graph.edges().forEach(function(e) {
      // hide the edges if its source or its target is not in the list of node to keep
      e.hidden = (!(toKeep.includes(e.source) && toKeep.includes(e.target)))
    })

    self.s.graph.nodes().forEach(function(n) {
      // Hide the node if it is not in the list of node to keep
      n.hidden = (!(toKeep.includes(n.id)))
    })

    self.s.refresh()
  }

  /**
   * Perform a filtering operation
   * @param add if we add (select) an association or if we remove it
   * @param association_name the association that we add or remove
   */
  filtering(add, association_name){
    if(add && !self.active_association.includes(association_name)){
      // The user adds an association
      self.active_association.push(association_name)
      this.filter_nodes_and_edges()
    }else if(!add && self.active_association.includes(association_name)){
      //the user filters out an association 
      self.active_association = self.active_association.filter(item => item !== association_name)
      this.filter_nodes_and_edges()
    }
  }

  /**
   * Handle the selection of a node
   * @param curId the currently selected node
   */
  click_on_node(curId){

    if(self.selected_nodes.has(curId)){
      // if the node is selected, remove it from the selection
      self.selected_nodes.delete(curId)
    }else{
      // If he node is not selected, add it to the list. 
      self.selected_nodes.add(curId)
    }

    // reset the selected neighbors
    self.selected_neighbors = new Set()

    // Add all the neighbors  of the selected nodes to the selected neighbors
    self.selected_nodes.forEach(n=>{
      s.graph.neighbors(n).forEach(
        e => self.selected_neighbors.add(e)
      )
    })

    // Remove all the nodes from the selected neighbours
    self.selected_nodes.forEach(n=>{
      self.selected_neighbors.delete(n)
    })

    // variable that will contain the association to which all the selected node belong
    var intersection_assoc = new Set(self.all_associations)

    // Iterate over all the nodes
    s.graph.nodes().forEach(n => {
      if(self.selected_nodes.size ==0){
        n.color = communityColors[n.node_data.community]
      }else{
        if(self.selected_nodes.has(n.id)) {
          n.color = selectedNodeColor
          intersection_assoc = new Set([...n.node_data.associated_groups].filter(a => intersection_assoc.has(a)))
        }else if(self.selected_neighbors.has(n.id)){
          n.color = communityColors[n.node_data.community]
        }else{
          n.color = notSelectedNodeColor
        }
      }
    })

    // Change the color of the edges based on the selection
    s.graph.edges().forEach(e=>{
      if((self.selected_nodes.has(e.source) ||self.selected_nodes.has(e.target)) && (self.selected_nodes.size!=0)){
        // the edge is bright if either one of the two vertex is selected or if the selection is empty
        e.color =  selectedEdgeColor
      }else{
        // otherwise the edge is "dark"
        e.color = notSelectedEdgeColor
      }
    })

    // create the list of common associations between all the selected characters. If the list of selected node is empty, we do not display anythings
    createAllList(self.selected_nodes.size == 0 ? new Set():intersection_assoc)
    s.refresh()
  }

  /**
   * Setup all the binding to have a reactive graph
   * @param s the sigma instance
   * 
   */
  setupBinding(s){
    // When we click on something else than a node
    s.bind('clickStage', e => {
      // Clear the association in common list 
      clearCommonAssoc()
      self.selected_nodes = new Set()
      self.selected_neighbors = new Set()
      // Deselect all the nodes 
      s.graph.nodes().forEach(n => {
          n.color = n.originalColor
      })
      s.graph.edges().forEach(e => {
          e.color = e.originalColor
      })
    })

    s.bind('clickNode', e => {
      this.click_on_node(e.data.node.id)
    })
    
    // if we double click on a node, we want to display all the information about the characters as in the house visualisation
    s.bind('doubleClickNode', e =>{
      this.click_on_node(e.data.node.id)
      setupModal(e.data.node.node_data, char_images, ext_img)
      $('#myModal').modal("show")
    })
  }

  /**
   * Focus on node in the graph. Zoom on it and click on it. 
   * @param the nodeId to which we should zoom
   */
  focus_node(nodeId){
    // Get the node correspond to this nodeId
    var node = self.s.graph.nodes().filter(n=> n.node_data.id == nodeId)[0]

    // Start the animation to the selected location
    sigma.misc.animation.camera(
    self.s.camera,
    {
      x: node[self.s.camera.readPrefix + 'x'],
      y: node[self.s.camera.readPrefix + 'y'],
      ratio: 0.3,
    },
    {
      duration: 150,
    },
  )
  // click on the node
  this.click_on_node(node.id)
  }

  /**
   * Build the SigmaJS graph 
   * 
   * @param graph the in a JSON format
   * @param all_associations the list of all available associations in the dataaset. 
   */
  create_network(graph, all_associations){
    // set the basic variables. 
    this.create_nodes(graph.nodes)
    this.create_edges(graph.edges)
    self.active_association = [...all_associations]
    self.all_associations = [...all_associations]
    // define the graph objects in the sigma expected format
    self.g = {nodes:self.nodes, edges:self.edges}
    // Create the sigma object
    var s = new sigma(
    {
      graph:self.g,
      renderer: {
        container: document.getElementById('sigma-container'), // container in which we will put the graph
        type: 'canvas'
      },
      settings: {
       labelColor: 'node',
       minEdgeSize: 0.1,
       maxEdgeSize: 2,
       minNodeSize: 5,
       maxNodeSize: 5,
       drawLabels: false, // Disable the text label display on loading
       doubleClickEnabled: false // Disable the zoom feature on double click
      }
    })

    // store the sigma instance in the object. 
    self.s = s
  
    // remember the original color of each npde
    s.graph.nodes().forEach(function(n) {
      n.originalColor = n.color;
      })

    // remember the original color of each edge
    s.graph.edges().forEach(function(e) {
      e.originalColor = e.color;
    })

    this.setupBinding(s)
    s.refresh()
  }
}

var sigmaGraph = new SigmaGraph(association_network)

/**
 * Create a set with all the associations
 * @param data the graph data
 */
function getAllAssociations(data){
  return new Set(data.nodes.flatMap(e=>e.associated_groups))
}


d3.json(association_network).then(d=>{
  // get the list of alla ssociations
  var assoc = getAllAssociations(d)

  // Setup searchbar
  var sel = d3.select("#search-char-cont")
              .append("select")
              .attr("class", "form-select inline-block")
              .attr("id","search-char")
  var btn = d3.select("#search-char-cont")
              .append("button")
              .attr("class", "btn btn-secondary col-2 inline-block")
              .text("Search in graph")
              .on("click",e=>sigmaGraph.focus_node(document.getElementById("search-char").value))

  var opts = sel.selectAll("option")
                .data(d.nodes.sort((a, b) => (a.name > b.name) ? 1 : -1)) // node in sorted order following her name.
                .enter()
                .append('option')
                .text(e =>  e.name)
                .attr("value", e=>e.id)
                .order()

  // Setup the filtering menu depending on the data 
  var menu = d3.select("#filter-menu")
                .append("ul")
                .attr("id","filter-menu-list")
                .classed("list-group", true)
                .selectAll(".filter-menu-item")
                .data(Array.from(assoc).sort()) // Add each of the association as an element of the list 
                .enter()
                .append('li')
                .attr("class", "filter-menu-item list-group-item list-group-item-dark")
                .classed("active-filter", true)
                .on("click", function(e) {
                  // change the background color depending on the element is selected or not
                  var assoc = e.srcElement.__data__
                  if(d3.select(this).classed("inactive-filter")){
                    d3.select(this).classed("active-filter", true)
                    d3.select(this).classed("inactive-filter", false)
                    // update sigma graph
                    sigmaGraph.filtering(true, assoc)
                  }else{
                    d3.select(this).classed("active-filter", false)
                    d3.select(this).classed("inactive-filter", true)
                     // update sigma graph
                     sigmaGraph.filtering(false, assoc)
                  }
                })
                .text(d=>d)
    menu.exit().remove()
  // Generate the graph using SigmaJS
  sigmaGraph.create_network(d, assoc)
})




